---
title: "Tidyr Soil"
author: "Apryl Perry, Clarice Perryman, Jochen Wirsing""
title: "Tidyr Soil"
author: "Apryl Perry"
date: "February 28, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Clear workspace (if desired/needed)
```{r}
rm(list = ls())
```

Load libraries
```{r}
library(tidyverse)
library(dplyr)
library(RCurl)
library(ggplot2)
library(reshape2)



```

Read in data file from Git, ignored first 4 rows - blank and or random file info, blank cells to NA
```{r}
downloadBSoil <- getURL("https://raw.githubusercontent.com/jagilman/Arctic-Ecol-Soc-2019/master/BestValue_Soil.csv") 
B_Soil <- read.csv(text = downloadBSoil, header = TRUE, skip = 4, na.strings = c(NA, ""))
```

Figure out which columns to remove/drop or expand 
Removed all columns ending with Sum, these are repeat info of existing columns. Create new df with only desired chemical species.  Add desired columns to chem database
```{r}
NoSum <- select (B_Soil, -c(ends_with('_Sum')))

USGS1 <- select(NoSum, matches('LAB_ID|FIELD_ID|DATE_SUBMITTED|DATE_COLLECT|LATITUDE|LONGITUDE|QUAD|SPHEROID|DATUM|DEPTH|SAMPLE_SOURCE|LOCATE_DESC|PRIMARY_CLASS|SAMPLE_COMMENT|SAMPLE_ZONE|HORIZON|ORGANICS|DRAINAGE|PREP|Hg_|Pb_|Ni_|As_|Cr_|Tl_'))


```

Filtering everything that has no info on the following:

* depth
* sample source

Then narrowed down columns.  

```{r latlon_depth}

USGS2 <- filter(USGS1, is.na(DEPTH) == FALSE)
USGS3 <- filter(USGS2, is.na(SAMPLE_SOURCE) == FALSE)
USGS4 <- select(USGS3,FIELD_ID, DATE_COLLECT, DEPTH, LOCATE_DESC, HORIZON, DATUM, LATITUDE, LONGITUDE, SAMPLE_SOURCE, As_ppm, As_ppm_AM, Cr_ppm, Cr_ppm_AM, Hg_ppm, Hg_ppm_AM, Ni_ppm, Ni_ppm_AM, Pb_ppm, Pb_ppm_AM) #dropped Tl - no data.

```

We need to wrangle the depths.... 
```{r}
#Recoding a chunk of depths to separate them correctly, removing non-numeric depths
USGS4$DEPTH <- recode(USGS4$DEPTH, "surface (0-25cm)"  = "0-25 cm")
USGS4$DEPTH <- recode(USGS4$DEPTH, "0- 5cm"  = "0-5 cm")#renaming several rows to get depth intervial
USGS4 <- filter(USGS4,!DEPTH  %in% c("unknown", "by horizon", "various", "A horizon", "B horizon", "C horizon", "surface", "Various", "loess", "loess ?")) 
##making units more consistent
USGS4$DEPTH<-str_replace(USGS4$DEPTH, "inches", "in")
USGS4$DEPTH<-str_replace(USGS4$DEPTH, "feet", "ft")
USGS4$DEPTH<-str_replace(USGS4$DEPTH, "'", " in")

#separate out units
USGS5 <- separate(USGS4, col="DEPTH", c("DEPTH", "UNIT"), sep = ' ')
#separate upper and lower units
USGS5 <- separate(USGS5, col="DEPTH", c("UPPPER", "LOWER"), sep = '-') %>% mutate_at(vars("UPPPER", "LOWER"), parse_number)

#remove bad split
USGS5 <- filter(USGS5, UNIT !="channel" )
#keep only rows with units
USGS5 <- filter(USGS5, UNIT %in% c("cm", "in", "ft"))


```

Now we need to convert units all to cm using a loop (probably)...work in progress...meanwhile I am going to do it offline so we can move forward. We can fix this part later - CP

```{r}
write.csv(USGS5, file = "filtered_USGS.csv")

downloadUSGS <- getURL("https://raw.githubusercontent.com/jagilman/Arctic-Ecol-Soc-2019/master/filtered_USGS.csv")
USGS_analyze <- read.csv(text=downloadUSGS, header = T, na.strings = "")
USGS_analyze$As_ppm <- as.numeric(USGS_analyze$As_ppm)
USGS_analyze$Cr_ppm <- as.numeric(USGS_analyze$Cr_ppm)
USGS_analyze$Ni_ppm <- as.numeric(USGS_analyze$Ni_ppm)
USGS_analyze$Hg_ppm <- as.numeric(USGS_analyze$Hg_ppm)

```

Looking at distributions of metals data with boxplots and Cleveland dot plots
```{r}
boxplot(USGS_analyze$As_ppm)
dotchart(USGS_analyze$As_ppm, xlab = "As (ppm)", xlim=c(-50,400),
         ylab = "Order of the data")
hist(USGS_analyze$As_ppm)

boxplot(USGS_analyze$Cr_ppm)
dotchart(USGS_analyze$Cr_ppm, xlab = "Cr (ppm)", xlim=c(-50,400),
         ylab = "Order of the data")
hist(USGS_analyze$Cr_ppm)

boxplot(USGS_analyze$Hg_ppm)
dotchart(USGS_analyze$Hg_ppm, xlab = "Hg (ppm)", xlim=c(-50,200),
         ylab = "Order of the data")
hist(USGS_analyze$Hg_ppm) #lots of ones? and cluster of >80
summary(USGS_analyze$Hg_ppm)

boxplot(USGS_analyze$Ni_ppm)
dotchart(USGS_analyze$Ni_ppm, xlab = "Ni (ppm)", xlim=c(-50,400),
         ylab = "Order of the data")
hist(USGS_analyze$Ni_ppm)

boxplot(USGS_analyze$Pb_ppm)
dotchart(USGS_analyze$Pb_ppm, xlab = "Pb (ppm)", xlim=c(-50,4000),
         ylab = "Order of the data") #one data point an order of magnitude higher than others....
hist(USGS_analyze$Pb_ppm)
```


Now...basic correlation plots of metals + lat/lon and depth
```{r}
USGS_numeric <- select(USGS_analyze,TOP_CM, LATITUDE, LONGITUDE, As_ppm, Cr_ppm, Hg_ppm, Ni_ppm, Pb_ppm) 

#creating a correlation matrix
cormat <- round(cor(USGS_numeric),2)
cormat

#"melting" the matrix (make longform)
melted_cormat <- melt(cormat)
head(melted_cormat)

#plot heatmap of correlation matrix
ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile()
```


```{r}
#Can't get this to work yet...I think something is wrong with the UPPER column? It says it's numeric...but it won't perform any mathematical operations on the column. 

#> USGS5$UPPER
#NULL
#> as.numeric(USGS5$UPPER)
#numeric(0)


###should work in theory...doesn't
converted <- mutate(USGS5, TOP = 
        ifelse(grepl("in", UNIT), USGS5$UPPER*2.54,
        ifelse(grepl("ft", UNIT), USGS5$UPPER*30.48, USGS5$UPPER*1))


###should work in theory...doesn't
USGS5$TOP <- ifelse(USGS5$UNIT %in% "in", USGS5$UPPER*2.54, USGS5$UPPER*1, 
ifelse(USGS5$UNIT %in% "ft", USGS5$UPPER*30.48, USGS5$UPPER*1))


```




Loading the whole US geochem file from Git -- national geochemical survey data base

And filtering for just alaska (by latitude > 52 deg north) and for just soil data

```{r load_us_geochem}
downloadUSgeochem <- getURL("https://raw.githubusercontent.com/jagilman/Arctic-Ecol-Soc-2019/master/geochem.csv")
usgeochem <- read.csv(text=downloadUSgeochem, header = T, na.strings = "")

AKgeochem <- filter(usgeochem, LATITUDE > 52.000 & TYPEDESC == "SOIL")


```


All previous filtering of Nat. GeoChem Survery below - tabled this dataset on 21 Marhc 2019

```{r chemfilter}


# Cleaner code - also fixing typo in varname
AKgeochem_2 <- select(AKgeochem,REC_NO,LABNO,LABNO2,FLDNAM,COLL_DATE,FLDNAM_AN,DESCRIPT,SOIL_HORIZ,SETTING,DATUM,LATITUDE,LONGITUDE,CONTAMSOU,CONTAMPOT,CONTAMDEGR,VEG,ANAL_NOTES,QUAD24CODE,FIPS,CATEGORY,TYPEDESC, matches('HG_|PB_|NI_|AS_|CD_|CR_|TL_'))

# we lose the variables PREV_LABNO & VEG_DENS, but I don't think they are wanted anyway


# Getting rid of NURE variables

AKgeochem_3 <- select(AKgeochem_2, -c(AS_NURE, CD_NURE, CR_NURE, HG_NURE, NI_NURE, PB_NURE))
##need to remove rows from DESCRIPT that lack depths

AKgeochem_4 <- filter(AKgeochem_3, DESCRIPT != "no sheet") #removes samples lacking info
AKgeochem_5 <-separate(AKgeochem_4, col="DESCRIPT", into=c("DEPTH", "DESCRIPT"), sep=";") #separates depth and description
AKgeochem_6 <- filter(AKgeochem_5, is.na(DESCRIPT) == FALSE) #removes *most* samples without depths, since their descriptions went into the DEPTH col when split
AKgeochem_7 <- slice(AKgeochem_6, c(1:17, 19:57, 59:149, 151:174, 176:181)) #remove rest of rows lacking depths that did not split correctly above

#filtering down to shared columns
AKgeochem_8 <- select(AKgeochem_7,FLDNAM,COLL_DATE,DEPTH,DESCRIPT,SOIL_HORIZ,DATUM,LATITUDE,LONGITUDE,VEG, AS_ICP40, AS_AA, AS_INAA, CD_ICP40, CR_ICP40, CR_INAA, NI_ICP40, NI_INAA, PB_ICP40)
##NOT Elegant but works! Here we are creating empty columns and filling them with analytical methods to match the USGS format
AKgeochem_9 <- separate(AKgeochem_8, col=c("AS_ICP40"), into=c("AS1", "AS_ICP"), sep=" ") 
AKgeochem_9$AS_ICP <- "AES_HF"
AKgeochem_9 <- separate(AKgeochem_9, col=c("AS_AA"), into=c("AS2", "AS_AA"), sep=" ")
AKgeochem_9$AS_AA <- "AA_HG_ST"
AKgeochem_9 <- separate(AKgeochem_9, col=c("AS_INAA"), into=c("AS3", "AS_INAA"), sep=" ") 
AKgeochem_9$AS_INAA <- "INAA"
AKgeochem_9 <- separate(AKgeochem_9, col=c("CD_ICP40"), into=c("CD", "CD_ICP"), sep=" ") 
AKgeochem_9$CD_ICP <- "AES_HF"
AKgeochem_9 <- separate(AKgeochem_9, col=c("CR_ICP40"), into=c("CR1", "CR_ICP"), sep=" ") 
AKgeochem_9$CR_ICP <- "AES_HF"
AKgeochem_9 <- separate(AKgeochem_9, col=c("CR_INAA"), into=c("CR2", "CR_INAA"), sep=" ") 
AKgeochem_9$CR_INAA <- "INAA"
AKgeochem_9 <- separate(AKgeochem_9, col=c("NI_ICP40"), into=c("NI", "NI_ICP"), sep=" ") 
AKgeochem_9$NI_ICP <- "AES_HF"
AKgeochem_9 <- separate(AKgeochem_9, col=c("NI_INAA"), into=c("NI2", "NI_INAA"), sep=" ") 
AKgeochem_9$NI_INAA <- "INAA"
AKgeochem_9 <- separate(AKgeochem_9, col=c("PB_ICP40"), into=c("PB", "PB_ICP"), sep=" ") 
AKgeochem_9$PB_ICP <- "AES_HF"

##now we need to use gather() to get a summary column of the concentrations and analytical methods for each element -- i.e. AS1, AS2, and AS3 become As_ppmm and AS_ICP, AS_AA, and AS_INAA become As_AM 

```


