---
title: "Tidyr Soil"
author: "Apryl Perry, Clarice Perryman, Jochen Wirsing""
title: "Tidyr Soil"
author: "Apryl Perry"
date: "February 28, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Clear workspace (if desired/needed)
```{r}
rm(list = ls())
```

Load libraries
```{r}
library(tidyverse)
library(dplyr)
library(RCurl)
library(ggplot2)
library(reshape2)
library(agricolae)


```

Read in data file from Git, ignored first 4 rows - blank and or random file info, blank cells to NA
```{r}
downloadBSoil <- getURL("https://raw.githubusercontent.com/jagilman/Arctic-Ecol-Soc-2019/master/BestValue_Soil.csv") 
B_Soil <- read.csv(text = downloadBSoil, header = TRUE, skip = 4, na.strings = c(NA, ""))
```

Figure out which columns to remove/drop or expand 
Removed all columns ending with Sum, these are repeat info of existing columns. Create new df with only desired chemical species.  Add desired columns to chem database
```{r}
NoSum <- select (B_Soil, -c(ends_with('_Sum')))

USGS1 <- select(NoSum, matches('LAB_ID|FIELD_ID|DATE_SUBMITTED|DATE_COLLECT|LATITUDE|LONGITUDE|QUAD|SPHEROID|DATUM|DEPTH|SAMPLE_SOURCE|LOCATE_DESC|PRIMARY_CLASS|SAMPLE_COMMENT|SAMPLE_ZONE|HORIZON|ORGANICS|DRAINAGE|PREP|Hg_|Pb_|Ni_|As_|Cr_|Tl_'))


```

Filtering everything that has no info on the following:

* depth
* sample source

Then narrowed down columns.  

```{r latlon_depth}

USGS2 <- filter(USGS1, is.na(DEPTH) == FALSE)
USGS3 <- filter(USGS2, is.na(SAMPLE_SOURCE) == FALSE)
USGS4 <- select(USGS3,FIELD_ID, DATE_COLLECT, DEPTH, LOCATE_DESC, HORIZON, DATUM, LATITUDE, LONGITUDE, SAMPLE_SOURCE, As_ppm, As_ppm_AM, Cr_ppm, Cr_ppm_AM, Hg_ppm, Hg_ppm_AM, Ni_ppm, Ni_ppm_AM, Pb_ppm, Pb_ppm_AM) #dropped Tl - no data.

```

We need to wrangle the depths.... 
```{r}
#Recoding a chunk of depths to separate them correctly, removing non-numeric depths
USGS4$DEPTH <- recode(USGS4$DEPTH, "surface (0-25cm)"  = "0-25 cm")
USGS4$DEPTH <- recode(USGS4$DEPTH, "0- 5cm"  = "0-5 cm")#renaming several rows to get depth intervial
USGS4 <- filter(USGS4,!DEPTH  %in% c("unknown", "by horizon", "various", "A horizon", "B horizon", "C horizon", "surface", "Various", "loess", "loess ?")) 
##making units more consistent
USGS4$DEPTH<-str_replace(USGS4$DEPTH, "inches", "in")
USGS4$DEPTH<-str_replace(USGS4$DEPTH, "feet", "ft")
USGS4$DEPTH<-str_replace(USGS4$DEPTH, "'", " in")

#separate out units
USGS5 <- separate(USGS4, col="DEPTH", c("DEPTH", "UNIT"), sep = ' ')
#separate upper and lower units
USGS5 <- separate(USGS5, col="DEPTH", c("UPPPER", "LOWER"), sep = '-') %>% mutate_at(vars("UPPPER", "LOWER"), parse_number)

#remove bad split
USGS5 <- filter(USGS5, UNIT !="channel" )
#keep only rows with units
USGS5 <- filter(USGS5, UNIT %in% c("cm", "in", "ft"))


```

Now we need to convert units all to cm using a loop (probably)...work in progress...meanwhile I am going to do it offline so we can move forward. We can fix this part later - CP

```{r}
#write.csv(USGS5, file = "filtered_USGS.csv")

downloadUSGS <- getURL("https://raw.githubusercontent.com/jagilman/Arctic-Ecol-Soc-2019/master/filtered_USGS.csv")
USGS_analyze <- read.csv(text=downloadUSGS, header = T, na.strings = "")
USGS_analyze$As_ppm <- as.numeric(USGS_analyze$As_ppm)
USGS_analyze$Cr_ppm <- as.numeric(USGS_analyze$Cr_ppm)
USGS_analyze$Ni_ppm <- as.numeric(USGS_analyze$Ni_ppm)
USGS_analyze$Hg_ppm <- as.numeric(USGS_analyze$Hg_ppm)

#taking out sources with only 1 sample
USGS_analyze <- filter(USGS_analyze, SAMPLE_SOURCE !="float" ) #only one sample with this source
USGS_analyze <- filter(USGS_analyze, SAMPLE_SOURCE !="wetland/swamp/marsh/bog/fen" ) #only one sample with this source

#this removed values that are all the same within the same analytical method/sampling site
USGS_analyze$As_ppm<- na_if(USGS_analyze$As_ppm, 310)
USGS_analyze$Cr_ppm<- na_if(USGS_analyze$Cr_ppm, 266)
USGS_analyze$Hg_ppm<- na_if(USGS_analyze$Hg_ppm, 87)
USGS_analyze$Ni_ppm<- na_if(USGS_analyze$Ni_ppm, 292)
##Remove negative values from Pb column
is.na(USGS_analyze$Pb_ppm) <- USGS_analyze$Pb_ppm < 0
#USGS_analyze$Pb_ppm<- na_if(USGS_analyze$Pb_ppm, 3800.0)
USGS_analyze$Pb_log <- log10(USGS_analyze$Pb_ppm)

#Renaming SAMPLE_SOURCE as "Source" for better lengend title below
colnames(USGS_analyze)[colnames(USGS_analyze)=="SAMPLE_SOURCE"] <- "Source"

#Lumping samples sources together into broader categories
USGS_analyze$Source <- recode(USGS_analyze$Source, "mine tailings"  = "mine-impacted")
USGS_analyze$Source <- recode(USGS_analyze$Source, "mine dump/prospect pit"  = "mine-impacted")
USGS_analyze$Source <- recode(USGS_analyze$Source, "forest/scattered timberland"  = "forested")
USGS_analyze$Source <- recode(USGS_analyze$Source, "permafrost"  = "tundra")
USGS_analyze$Source <- recode(USGS_analyze$Source, "shrub covered"  = "tundra")
USGS_analyze$Source <- recode(USGS_analyze$Source, "grassland/grazing land/cultivated land"  = "tundra")
USGS_analyze$Source <- recode(USGS_analyze$Source, "tundra/alpine tundra"  = "tundra")
USGS_analyze$Source <- recode(USGS_analyze$Source, "glacial debris/deposit"  = "glacial deposit")
USGS_analyze$Source <- recode(USGS_analyze$Source, "surface"  = "sedge/moss/shrub wetland")

#This tells R to plot the depths in this order, not alphbetically. 
USGS_analyze$Depth <- factor(USGS_analyze$Depth, levels = c("surface", "mid", "deep"))

#source_depth_map <- write.csv(USGS_analyze, file="Map_data_5April2019")
```

Looking at distributions of metals data with basic boxplots, Cleveland dot plots, and histograms to look at distrubtions (commented out for now). 

```{r}
#boxplot(USGS_analyze$As_ppm)
#dotchart(USGS_analyze$As_ppm, xlab = "As (ppm)", xlim=c(-50,400), ylab = "Order of the data")
#hist(USGS_analyze$As_ppm)
#boxplot(USGS_analyze$As_ppm ~ USGS_analyze$SAMPLE_SOURCE)

#boxplot(USGS_analyze$Cr_ppm)
#dotchart(USGS_analyze$Cr_ppm, xlab = "Cr (ppm)", xlim=c(-50,400), ylab = "Order of the data")
#hist(USGS_analyze$Cr_ppm)

#boxplot(USGS_analyze$Hg_ppm)
#dotchart(USGS_analyze$Hg_ppm, xlab = "Hg (ppm)", xlim=c(-50,200), ylab = "Order of the data")
#hist(USGS_analyze$Hg_ppm) #lots of ones? and cluster of >80

#boxplot(USGS_analyze$Ni_ppm)
#dotchart(USGS_analyze$Ni_ppm, xlab = "Ni (ppm)", xlim=c(-50,400), ylab = "Order of the data")
#hist(USGS_analyze$Ni_ppm)


#boxplot(USGS_analyze$Pb_ppm)
#dotchart(USGS_analyze$Pb_ppm, xlab = "Pb (ppm)", xlim=c(-50,4000), ylab = "Order of the data") #one data point an order of magnitude higher than others....
#hist(USGS_analyze$Pb_ppm)
```


Making nicers box plots to look at concentration by sample source. Starting w/ As: 

```{r}

#creating a reference data matrix of sample sources and HEX codes to have consistent color scheme across plots 

#Counts for annotation 
As_count <- select(USGS_analyze, Source, TOP_CM, Depth, As_ppm)
As_count<- filter(As_count, !is.na(As_ppm))
As_count %>% 
  group_by(Source) %>%
  summarise(no_rows = length(Source))


##Arsenic boxplot
As_plot <- ggplot(USGS_analyze, aes(Source, As_ppm, fill=Source)) + 
   geom_boxplot() +
  xlab("source") +
  ylab("As (mg/kg)") +
  theme_classic()+
   theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

#adds correct colors and number of obs.
As_plot + scale_fill_manual(values=c("#b3de69", "#80b1d3", "#fdb462", "#fb8072", "#bebada")) + annotate("text", x = 1:5, y = -7, label = c("277", "82", "531", "19", "172"))  + geom_hline(yintercept=7.2, linetype="dashed", size=1.25, color="darkgrey") + stat_summary(fun.y=mean, geom="point", shape=23, size=3, color="black", fill="white") +ylim(-10,320) + annotate("text", x = 1:5, y = 320, label = c("b", "a", "a", "a", "a"))

shapiro.test(USGS_analyze$As_ppm) #tests for normality, p < 0.001
bartlett.test(As_ppm~Source, data=USGS_analyze) #tests for homogeneity of variance, p = 0.89

#using Kruskal-Wallis test in lieu of an ANOVA because of the lack of normality
As_bySource <- kruskal(USGS_analyze$As_ppm, USGS_analyze$Source, group=TRUE, p.adj = "bonferroni")
As_bySource #Chi-sq = 51.8, Df = 4, p < 0.001
#mine-impacted                            a
#sedge/moss/shrub wetland                 a
#glacial deposit                          a
#tundra                                   a
#forested                                 b



#plot by depth
As_depth <- ggplot(USGS_analyze, aes(Depth, As_ppm, fill=Depth)) + 
   geom_boxplot() +
  xlab("source") +
  ylab("As (mg/kg)") +
  theme_classic()+
   theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

#adds colors and labels
As_depth + scale_fill_manual(values=c("#fee0d2", "#fc9272", "#de2d26")) + annotate("text", x = 1:3, y = 325, label = c("843", "160", "78")) + geom_hline(yintercept=7.2, linetype="dashed", size=1.25, color="darkgrey")

#Getting count by depth for annotating
As_count %>% 
  group_by(Depth) %>%
  summarise(no_rows = length(Depth))
```

Boxplots for Cr
```{r}
#Counts for annotation
Cr_count <- select(USGS_analyze, Source, TOP_CM, Depth, Cr_ppm)
Cr_count<- filter(Cr_count, !is.na(Cr_ppm))
Cr_count %>% 
  group_by(Source) %>%
  summarise(no_rows = length(Source))

##Chromium by source boxplot
Cr_plot <- ggplot(USGS_analyze, aes(Source, Cr_ppm, fill=Source)) + 
  geom_boxplot() +
  xlab("source") +
  ylab("Cr (mg/kg)") +
  theme_classic()+
   theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

#adds correct colors and number of obs. 
Cr_plot + scale_fill_manual(values=c("#b3de69", "#80b1d3", "#fdb462", "#fb8072", "#bebada")) + geom_hline(yintercept=100, linetype="dashed", size=1.25) + annotate("text", x = 1:5, y = -10, label = c("277", "82", "531", "19", "172")) + geom_hline(yintercept=37, linetype="dashed", size=1.25, color="darkgrey") + stat_summary(fun.y=mean, geom="point", shape=23, size=3, color="black", fill="white") + ylim(-10,300) + annotate("text", x = 1:5, y = 300, label = c("ab", "a", "b", "ab", "a"))
##Line values from WHO permissible limits for heavy metals in plant and soil (1996)

shapiro.test(USGS_analyze$Cr_ppm) #tests for normality, p < 0.001
bartlett.test(Cr_ppm~Source, data=USGS_analyze) #tests for homogeneity of variance, p < 0.001

#using Kruskal-Wallis test in lieu of an ANOVA because of the lack of normality
Cr_bySource <- kruskal(USGS_analyze$Cr_ppm, USGS_analyze$Source, group=TRUE, p.adj = "bonferroni")
Cr_bySource #Chi-sq = 42.9, Df = 4, p < 0.001
#glacial deposit                           a
#sedge/moss/shrub wetland                  a
#mine-impacted                             ab
#forested                                  ab
#tundra                                    b


#plot by depth
Cr_depth <- ggplot(USGS_analyze, aes(Depth, Cr_ppm, fill=Depth)) + 
  geom_boxplot() +
  xlab("source") +
  ylab("Cr (mg/kg)") +
  theme_classic()+
   theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

Cr_depth + scale_fill_manual(values=c("#fee6ce", "#fdae6b", "#e6550d")) + geom_hline(yintercept=100, linetype="dashed", size=1.25) + annotate("text", x = 1:3, y = 300, label = c("843", "160", "78"))+ geom_hline(yintercept=37, linetype="dashed", size=1.25, color="darkgrey")

#getting count for Depth
Cr_count %>% 
  group_by(Depth) %>%
  summarise(no_rows = length(Depth))

```


Boxplots for Hg
```{r}
#Counts for annotation
Hg_count <- select(USGS_analyze, Source, Depth, TOP_CM, Hg_ppm)
Hg_count<- filter(Hg_count, !is.na(Hg_ppm))
Hg_count %>% 
  group_by(Source) %>%
  summarise(no_rows = length(Source))

##Mercury by source boxplot
Hg_plot <- ggplot(USGS_analyze, aes(Source, Hg_ppm, fill=Source)) + 
  geom_boxplot() +
  xlab("source") +
  ylab("Hg (mg/kg)") +
  theme_classic()+
   theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

#adds correct colors and number of obs. 
Hg_plot + scale_fill_manual(values=c("#b3de69", "#80b1d3", "#fdb462", "#fb8072", "#bebada")) + annotate("text", x = 1:5, y = 100, label = c("139", "82", "440", "12", "172")) + stat_summary(fun.y=mean, geom="point", shape=23, size=3, color="black", fill="white")

shapiro.test(USGS_analyze$Hg_ppm) #tests for normality, p < 0.001
bartlett.test(Hg_ppm~Source, data=USGS_analyze) #tests for homogeneity of variance, p < 0.001

#using Kruskal-Wallis test in lieu of an ANOVA because of the lack of normality
Hg_bySource <- kruskal(USGS_analyze$Hg_ppm, USGS_analyze$Source, group=TRUE, p.adj = "bonferroni")
Hg_bySource #Chi-sq = 82.8, Df = 4, p < 0.001
#mine-impacted                             a
#glacial deposit                           b
#sedge/moss/shrub wetland                  c
#tundra                                    c
#forested                                  d


#plot by depth
Hg_depth <- ggplot(USGS_analyze, aes(Depth, Hg_ppm, fill=Depth)) + 
  geom_boxplot() +
  xlab("source") +
  ylab("Hg (mg/kg)") +
  theme_classic()+
   theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

#adds correct colors and number of obs. 
Hg_depth + scale_fill_manual(values=c("#e5f5e0", "#a1d99b", "#31a354")) + annotate("text", x = 1:3, y = 100, label = c("628", "159", "58"))

#getting depth counts
Hg_count %>% 
  group_by(Depth) %>%
  summarise(no_rows = length(Depth))
```


Boxplots for Ni
```{r}
##gets counts for annotation
Ni_count <- select(USGS_analyze, Source, Depth, TOP_CM, Ni_ppm)
Ni_count<- filter(Ni_count, !is.na(Ni_ppm))
Ni_count %>% 
  group_by(Source) %>%
  summarise(no_rows = length(Source))

##Nickel by source boxplot
Ni_plot <- ggplot(USGS_analyze, aes(Source, Ni_ppm, fill=Source)) + 
  geom_boxplot() +
  xlab("source") +
  ylab("Ni (mg/kg)") +
  theme_classic()+ 
   theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

#adds correct colors and number of obs. 
Ni_plot + scale_fill_manual(values=c("#b3de69", "#80b1d3", "#fdb462", "#fb8072", "#bebada")) + geom_hline(yintercept=35, linetype="dashed", size=1.25) + annotate("text", x = 1:5, y = 300, label = c("277", "82", "531", "19", "172")) + geom_hline(yintercept=40, linetype="dashed", size=1.25, color="darkgrey") + stat_summary(fun.y=mean, geom="point", shape=23, size=3, color="black", fill="white")
##Line values from WHO permissible limits for heavy metals in plant and soil (1996)

shapiro.test(USGS_analyze$Ni_ppm) #tests for normality, p < 0.001
bartlett.test(Ni_ppm~Source, data=USGS_analyze) #tests for homogeneity of variance, p < 0.0002

#using Kruskal-Wallis test in lieu of an ANOVA because of the lack of normality
Ni_bySource <- kruskal(USGS_analyze$Ni_ppm, USGS_analyze$Source, group=TRUE, p.adj = "bonferroni")
Ni_bySource #Chi-sq = 74.01, Df = 4, p < 0.001
#mine-impacted                             a
#tundra                                    b
#forested                                 bc
#sedge/moss/shrub wetland                  c
#glacial deposit                           d

#depth plot
Ni_depth <- ggplot(USGS_analyze, aes(Depth, Ni_ppm, fill=Depth)) + 
  geom_boxplot() +
  xlab("source") +
  ylab("Ni (mg/kg)") +
  theme_classic()+ 
   theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

#adds correct colors and number of obs. 
Ni_depth + scale_fill_manual(values=c("#deebf7", "#9ecae1","#3182bd")) + geom_hline(yintercept=35, linetype="dashed", size=1.25) + annotate("text", x = 1:3, y = 300, label = c("843", "160", "78"))  + geom_hline(yintercept=40, linetype="dashed", size=1.25, color="darkgrey")


#getting depth count
Ni_count %>% 
  group_by(Depth) %>%
  summarise(no_rows = length(Depth))
```


Boxplots for Pb
```{r}
##getting counts for each source type to annotate figure 
Pb_count <- select(USGS_analyze, Source, Depth, TOP_CM, Pb_ppm, Pb_log)
Pb_count<- filter(Pb_count, !is.na(Pb_ppm))
Pb_count %>% 
  group_by(Source) %>%
  summarise(no_rows = length(Source))

##Lead by source boxplot
Pb_plot <- ggplot(USGS_analyze, aes(Source, Pb_log, fill=Source)) + 
   geom_boxplot() +
  xlab("source") +
  ylab("log [Pb (mg/kg)]") +
  theme_classic()+
   theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

#adds correct colors and number of obs. 
Pb_plot + scale_fill_manual(values=c("#b3de69", "#80b1d3", "#fdb462", "#fb8072", "#bebada")) + geom_hline(yintercept=1.9294, linetype="dashed", size=1.25) + annotate("text", x = 1:5, y = 3.25, label = c("231", "82", "582", "19", "166"))  + geom_hline(yintercept=1.477, linetype="dashed", size=1.25, color="darkgrey") + stat_summary(fun.y=mean, geom="point", shape=23, size=3, color="black", fill="white")
##Line values from WHO permissible limits for heavy metals in plant and soil (1996)

shapiro.test(USGS_analyze$Pb_ppm) #tests for normality, p < 0.001
bartlett.test(Pb_ppm~Source, data=USGS_analyze) #tests for homogeneity of variance, p < 0.001

#using Kruskal-Wallis test in lieu of an ANOVA because of the lack of normality
Pb_bySource <- kruskal(USGS_analyze$Pb_ppm, USGS_analyze$Source, group=TRUE, p.adj = "bonferroni")
Pb_bySource #Chi-sq = 122.58, Df = 4, p < 0.001
#mine-impacted                             a
#forested                                  b
#tundra                                    b
#glacial deposit                           b
#sedge/moss/shrub wetland                  c

##By depth
Pb_depth <- ggplot(USGS_analyze, aes(Depth, Pb_log, fill=Depth)) + 
   geom_boxplot() +
  xlab("source") +
  ylab("log [Pb (mg/kg)]") +
  theme_classic()+
   theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

Pb_depth + scale_fill_manual(values=c("#efedf5", "#bcbddc","#756bb1")) + geom_hline(yintercept=1.9294, linetype="dashed", size=1.25) + annotate("text", x = 1:3, y = 3.25, label = c("843","159","78"))  + geom_hline(yintercept=1.477, linetype="dashed", size=1.25, color="darkgrey")
##Line values from WHO permissible limits for heavy metals in plant and soil (1996)

##depth counts
Pb_count %>% 
  group_by(Depth) %>%
  summarise(no_rows = length(Depth))
```

Now...basic correlation plots of metals + lat/lon and depth
```{r}
USGS_numeric <- select(USGS_analyze,TOP_CM, LATITUDE, LONGITUDE, As_ppm, Cr_ppm, Hg_ppm, Ni_ppm, Pb_ppm) 

#creating a correlation matrix
cormat <- round(cor(USGS_numeric),2)
cormat

#"melting" the matrix (make longform)
melted_cormat <- melt(cormat)
head(melted_cormat)

#plot heatmap of correlation matrix
ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile()
```

Ordination plot? ISSUE - missing values. 
```{r}
##removing NAs - can't do a PCA w/ NAs
PCA_matrix <- filter(USGS_analyze, !is.na(As_ppm))
PCA_matrix <- filter(PCA_matrix, !is.na(Cr_ppm))
PCA_matrix <- filter(PCA_matrix, !is.na(Hg_ppm))
PCA_matrix <- filter(PCA_matrix, !is.na(Ni_ppm))
PCA_matrix <- filter(PCA_matrix, !is.na(Pb_ppm))

#now seaprating out just the metals concentrations for PCA
Main_matrix_metals <- select(PCA_matrix, As_ppm, Cr_ppm, Hg_ppm, Ni_ppm, Pb_ppm)

##Hg and Pb are very skewed, and the magnitudes (ie "abundances") of the values for metals vary between metal types - log transforming to limit affect of skew/mags on ordination
Log_metals <- log10(Main_matrix_metals)

#princomp runs the PCA, I am telling it not to center/scale columns by setting scale = FALSE. Need ggfortify package to plot using autoplot()
#install.packages("ggfortify")
library("ggfortify")

metals.pca <- princomp(Main_matrix_metals, cor = TRUE, scores = TRUE)
summary(metals.pca) #the summary tells you how much proportional and cumulative variance in the metals dataset each principle component (axis) explains 
metals.pca$loadings ##the loadings say how much each variable contributes to variance in that "direction"

#starting to plot
#plot log transformed and not to see how the points clump differenly, log transformed clusters in corner but not by sample source...not transformed is all over the place
autoplot(princomp(Main_matrix_metals), data=PCA_matrix, colour = "Source")
autoplot(princomp(Log_metals), data=PCA_matrix, colour = "Depth")

```


```{r}
#Can't get this to work yet...I think something is wrong with the UPPER column? It says it's numeric...but it won't perform any mathematical operations on the column. 

#> USGS5$UPPER
#NULL
#> as.numeric(USGS5$UPPER)
#numeric(0)


###should work in theory...doesn't
converted <- mutate(USGS5, TOP = 
        ifelse(grepl("in", UNIT), USGS5$UPPER*2.54,
        ifelse(grepl("ft", UNIT), USGS5$UPPER*30.48, USGS5$UPPER*1))


###should work in theory...doesn't
USGS5$TOP <- ifelse(USGS5$UNIT %in% "in", USGS5$UPPER*2.54, USGS5$UPPER*1, 
ifelse(USGS5$UNIT %in% "ft", USGS5$UPPER*30.48, USGS5$UPPER*1))


```




Loading the whole US geochem file from Git -- national geochemical survey data base

And filtering for just alaska (by latitude > 52 deg north) and for just soil data

```{r load_us_geochem}
downloadUSgeochem <- getURL("https://raw.githubusercontent.com/jagilman/Arctic-Ecol-Soc-2019/master/geochem.csv")
usgeochem <- read.csv(text=downloadUSgeochem, header = T, na.strings = "")

AKgeochem <- filter(usgeochem, LATITUDE > 52.000 & TYPEDESC == "SOIL")


```


All previous filtering of Nat. GeoChem Survery below - tabled this dataset on 21 Marhc 2019

```{r chemfilter}


# Cleaner code - also fixing typo in varname
AKgeochem_2 <- select(AKgeochem,REC_NO,LABNO,LABNO2,FLDNAM,COLL_DATE,FLDNAM_AN,DESCRIPT,SOIL_HORIZ,SETTING,DATUM,LATITUDE,LONGITUDE,CONTAMSOU,CONTAMPOT,CONTAMDEGR,VEG,ANAL_NOTES,QUAD24CODE,FIPS,CATEGORY,TYPEDESC, matches('HG_|PB_|NI_|AS_|CD_|CR_|TL_'))

# we lose the variables PREV_LABNO & VEG_DENS, but I don't think they are wanted anyway


# Getting rid of NURE variables

AKgeochem_3 <- select(AKgeochem_2, -c(AS_NURE, CD_NURE, CR_NURE, HG_NURE, NI_NURE, PB_NURE))
##need to remove rows from DESCRIPT that lack depths

AKgeochem_4 <- filter(AKgeochem_3, DESCRIPT != "no sheet") #removes samples lacking info
AKgeochem_5 <-separate(AKgeochem_4, col="DESCRIPT", into=c("DEPTH", "DESCRIPT"), sep=";") #separates depth and description
AKgeochem_6 <- filter(AKgeochem_5, is.na(DESCRIPT) == FALSE) #removes *most* samples without depths, since their descriptions went into the DEPTH col when split
AKgeochem_7 <- slice(AKgeochem_6, c(1:17, 19:57, 59:149, 151:174, 176:181)) #remove rest of rows lacking depths that did not split correctly above

#filtering down to shared columns
AKgeochem_8 <- select(AKgeochem_7,FLDNAM,COLL_DATE,DEPTH,DESCRIPT,SOIL_HORIZ,DATUM,LATITUDE,LONGITUDE,VEG, AS_ICP40, AS_AA, AS_INAA, CD_ICP40, CR_ICP40, CR_INAA, NI_ICP40, NI_INAA, PB_ICP40)
##NOT Elegant but works! Here we are creating empty columns and filling them with analytical methods to match the USGS format
AKgeochem_9 <- separate(AKgeochem_8, col=c("AS_ICP40"), into=c("AS1", "AS_ICP"), sep=" ") 
AKgeochem_9$AS_ICP <- "AES_HF"
AKgeochem_9 <- separate(AKgeochem_9, col=c("AS_AA"), into=c("AS2", "AS_AA"), sep=" ")
AKgeochem_9$AS_AA <- "AA_HG_ST"
AKgeochem_9 <- separate(AKgeochem_9, col=c("AS_INAA"), into=c("AS3", "AS_INAA"), sep=" ") 
AKgeochem_9$AS_INAA <- "INAA"
AKgeochem_9 <- separate(AKgeochem_9, col=c("CD_ICP40"), into=c("CD", "CD_ICP"), sep=" ") 
AKgeochem_9$CD_ICP <- "AES_HF"
AKgeochem_9 <- separate(AKgeochem_9, col=c("CR_ICP40"), into=c("CR1", "CR_ICP"), sep=" ") 
AKgeochem_9$CR_ICP <- "AES_HF"
AKgeochem_9 <- separate(AKgeochem_9, col=c("CR_INAA"), into=c("CR2", "CR_INAA"), sep=" ") 
AKgeochem_9$CR_INAA <- "INAA"
AKgeochem_9 <- separate(AKgeochem_9, col=c("NI_ICP40"), into=c("NI", "NI_ICP"), sep=" ") 
AKgeochem_9$NI_ICP <- "AES_HF"
AKgeochem_9 <- separate(AKgeochem_9, col=c("NI_INAA"), into=c("NI2", "NI_INAA"), sep=" ") 
AKgeochem_9$NI_INAA <- "INAA"
AKgeochem_9 <- separate(AKgeochem_9, col=c("PB_ICP40"), into=c("PB", "PB_ICP"), sep=" ") 
AKgeochem_9$PB_ICP <- "AES_HF"

##now we need to use gather() to get a summary column of the concentrations and analytical methods for each element -- i.e. AS1, AS2, and AS3 become As_ppmm and AS_ICP, AS_AA, and AS_INAA become As_AM 

```


